<!DOCTYPE html><html><!-- Built with spec-md --><head><meta charset="utf-8"><title>Mantra</title><link href="spec.css" rel="stylesheet"><link href="highlight.css" rel="stylesheet"></head><body><header><h1>Mantra</h1><section id="intro"><p><em>Working Draft - <a href="https://github.com/kadirahq/mantra/blob/master/CHANGELOG.md">Version 0.2.0</a></em></p><p><strong>Introduction</strong></p><p>This is a Draft Specification for Mantra, an application architecture for Meteor created by <a href="https://kadira.io/">Kadira</a>. It helps developers build maintainable, future&#8208;proof Meteor apps.</p><p><strong>Copyright notice</strong></p><p>The MIT License (MIT)</p><p>Copyright (c) 2016 Kadira Inc. <hello@kadira.io></p><p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &ldquo;Software&rdquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p><p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p><p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></section><div class="spec-toc"><ol><li><a href="#sec-Overview"><span class="spec-secid">1</span>Overview</a><ol><li><a href="#sec-What-s-Inside-Mantra-"><span class="spec-secid">1.1</span>What&#x27;s Inside Mantra?</a></li><li><a href="#sec-What-is-Mantra-Not-"><span class="spec-secid">1.2</span>What is Mantra Not?</a></li><li><a href="#sec-What-is-Mantra-"><span class="spec-secid">1.3</span>What is Mantra?</a></li><li><a href="#sec-Why-a-Spec-"><span class="spec-secid">1.4</span>Why a Spec?</a></li><li><a href="#sec-Before-You-Read"><span class="spec-secid">1.5</span>Before You Read</a></li></ol></li><li><a href="#sec-Core-Components"><span class="spec-secid">2</span>Core Components</a><ol><li><a href="#sec-Client-Side-Focus"><span class="spec-secid">2.1</span>Client-Side Focus</a></li><li><a href="#sec-ES2015-Syntax-and-ES2015-Modules"><span class="spec-secid">2.2</span>ES2015 Syntax and ES2015 Modules</a></li><li><a href="#sec-React-as-the-UI"><span class="spec-secid">2.3</span>React as the UI</a></li><li><a href="#sec-Actions"><span class="spec-secid">2.4</span>Actions</a></li><li><a href="#sec-State-Management"><span class="spec-secid">2.5</span>State Management</a></li><li><a href="#sec-Containers"><span class="spec-secid">2.6</span>Containers</a></li><li><a href="#sec-Application-Context"><span class="spec-secid">2.7</span>Application Context</a></li><li><a href="#sec-Dependency-Injection"><span class="spec-secid">2.8</span>Dependency Injection</a><ol><li><a href="#sec-Configuring-Dependency-Injections"><span class="spec-secid">2.8.1</span>Configuring Dependency Injections</a></li></ol></li><li><a href="#sec-Routing-Component-Mounting"><span class="spec-secid">2.9</span>Routing &amp; Component Mounting</a></li><li><a href="#sec-Libraries"><span class="spec-secid">2.10</span>Libraries</a></li><li><a href="#sec-Testing"><span class="spec-secid">2.11</span>Testing</a><ol><li><a href="#sec-UI-Testing"><span class="spec-secid">2.11.1</span>UI Testing</a></li></ol></li><li><a href="#sec-Mantra-Modules"><span class="spec-secid">2.12</span>Mantra Modules</a><ol><li><a href="#sec-Application-Context-Modules"><span class="spec-secid">2.12.1</span>Application Context &amp; Modules</a></li><li><a href="#sec-Module-Definition"><span class="spec-secid">2.12.2</span>Module Definition</a></li><li><a href="#sec-Implicit-Modules"><span class="spec-secid">2.12.3</span>Implicit Modules</a></li><li><a href="#sec-Module-Containers-UI-Components"><span class="spec-secid">2.12.4</span>Module Containers &amp; UI Components</a></li><li><a href="#sec-Module-Actions"><span class="spec-secid">2.12.5</span>Module Actions</a></li><li><a href="#sec-Routes"><span class="spec-secid">2.12.6</span>Routes</a></li><li><a href="#sec-Core-Module"><span class="spec-secid">2.12.7</span>Core Module</a></li><li><a href="#sec-Sub-Modules"><span class="spec-secid">2.12.8</span>Sub Modules</a></li></ol></li><li><a href="#sec-Single-Entry-Point"><span class="spec-secid">2.13</span>Single Entry Point</a></li></ol></li><li><a href="#sec-Directory-Layout"><span class="spec-secid">3</span>Directory Layout</a><ol><li><a href="#sec-Top-Level-Directory-Structure"><span class="spec-secid">3.1</span>Top-Level Directory Structure</a><ol><li><a href="#sec-Top-Level-Directory-Structure.configs"><span class="spec-secid">3.1.1</span>configs</a></li><li><a href="#sec-modules"><span class="spec-secid">3.1.2</span>modules</a><ol><li><a href="#sec-actions"><span class="spec-secid">3.1.2.1</span>actions</a></li><li><a href="#sec-components"><span class="spec-secid">3.1.2.2</span>components</a></li><li><a href="#sec-containers"><span class="spec-secid">3.1.2.3</span>containers</a></li><li><a href="#sec-modules.configs"><span class="spec-secid">3.1.2.4</span>configs</a></li><li><a href="#sec-modules.libs"><span class="spec-secid">3.1.2.5</span>libs</a></li><li><a href="#sec-routes-jsx"><span class="spec-secid">3.1.2.6</span>routes.jsx</a></li><li><a href="#sec-index-js"><span class="spec-secid">3.1.2.7</span>index.js</a></li></ol></li><li><a href="#sec-Top-Level-Directory-Structure.main-js"><span class="spec-secid">3.1.3</span>main.js</a></li></ol></li></ol></li><li><a href="#sec-Future-Work"><span class="spec-secid">4</span>Future Work</a><ol><li><a href="#sec-Server-Side-Rendering-SSR-"><span class="spec-secid">4.1</span>Server-Side Rendering (SSR)</a></li><li><a href="#sec-Distributing-Mantra-Modules-via-NPM"><span class="spec-secid">4.2</span>Distributing Mantra Modules via NPM</a></li><li><a href="#sec-Standard-for-Styling"><span class="spec-secid">4.3</span>Standard for Styling</a></li><li><a href="#sec-Standard-for-Tests"><span class="spec-secid">4.4</span>Standard for Tests</a></li><li><a href="#sec-Reusing-Composers"><span class="spec-secid">4.5</span>Reusing Composers</a></li></ol></li><li><a href="#sec-Contributing-to-Mantra"><span class="spec-secid">5</span>Contributing to Mantra</a></li><li><a href="#sec-Appendix-Prerequisite"><span class="spec-secid">A</span>Appendix: Prerequisite</a><ol><li><a href="#sec-ES2015"><span class="spec-secid">A.1</span>ES2015</a></li><li><a href="#sec-React"><span class="spec-secid">A.2</span>React</a></li><li><a href="#sec-React-Containers"><span class="spec-secid">A.3</span>React Containers</a></li><li><a href="#sec-Meteor-Basics"><span class="spec-secid">A.4</span>Meteor Basics</a></li></ol></li><li><a href="#sec-Appendix-Server-Side-Directory-Layout"><span class="spec-secid">B</span>Appendix: Server-Side Directory Layout</a><ol><li><a href="#sec-methods"><span class="spec-secid">B.1</span>methods</a><ol><li><a href="#sec-Tests"><span class="spec-secid">B.1.1</span>Tests</a></li></ol></li><li><a href="#sec-publications"><span class="spec-secid">B.2</span>publications</a></li><li><a href="#sec-Appendix-Server-Side-Directory-Layout.libs"><span class="spec-secid">B.3</span>libs</a></li><li><a href="#sec-Appendix-Server-Side-Directory-Layout.configs"><span class="spec-secid">B.4</span>configs</a></li><li><a href="#sec-Appendix-Server-Side-Directory-Layout.main-js"><span class="spec-secid">B.5</span>main.js</a></li></ol></li><li><a href="#sec-Appendix-Organizing-Modules"><span class="spec-secid">C</span>Appendix: Organizing Modules</a><ol><li><a href="#sec-Single-Core-Module"><span class="spec-secid">C.1</span>Single Core Module</a></li><li><a href="#sec-Core-Module-Multiple-Feature-Modules"><span class="spec-secid">C.2</span>Core Module &amp; Multiple Feature Modules</a></li><li><a href="#sec-Multi-Modules"><span class="spec-secid">C.3</span>Multi Modules</a></li><li><a href="#sec-Pages-Module"><span class="spec-secid">C.4</span>Pages Module</a></li></ol></li><li><a href="#sec-Appendix-File-Naming-Conventions"><span class="spec-secid">D</span>Appendix: File Naming Conventions</a><ol><li><a href="#sec-Source-File-Names"><span class="spec-secid">D.1</span>Source File Names</a></li><li><a href="#sec-Test-File-Names"><span class="spec-secid">D.2</span>Test File Names</a><ol><li><a href="#sec-Postfix"><span class="spec-secid">D.2.1</span>Postfix</a></li></ol></li></ol></li></ol></div></header><section id="sec-Overview"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Overview">1</a></span>Overview</h2><p>Mantra is an application architecture for <a href="https://www.meteor.com/">Meteor</a>. With Mantra, we are trying to achieve two main goals.</p><p><strong>1. Maintainability</strong></p><p>Maintainability is a key factor for success when working with a large team. We achieve this by unit testing every part of our app, while following standards for everything. Then it&rsquo;s easy to onboard new users and work with teams.</p><p><strong>2. Future Proof</strong></p><p>JavaScript is a land of choices. We have more than one best solution for each problem. It can be hard to tell what&rsquo;s the best solution now and what will change in the future.</p><p>Mantra relies on a set of core principles that will last for a long time. Then, we allow others to change as needed.</p><section id="sec-What-s-Inside-Mantra-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-s-Inside-Mantra-">1.1</a></span>What&#x27;s Inside Mantra?</h3><ul><li>It has a modern, React&#8208;based <strong>UI component</strong> layer.</li><li>It has a place to define business logic in your app. We call them <strong>actions</strong>.</li><li>State management is not provided by Mantra itself, but it allows you to use a wide variety of state managers, including Meteor/Tracker, Redux, Rx.js Observables, Promises, and nearly anything else.</li><li>It has a way to integrate both states and actions into UI components by composing containers.</li><li>It allows you to inject dependencies.</li><li>It helps you to unit test UI, actions, and integrations (containers).</li><li>It has standards for directory layout, file naming, and everything else.</li></ul></section><section id="sec-What-is-Mantra-Not-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-Mantra-Not-">1.2</a></span>What is Mantra Not?</h3><ul><li>It&rsquo;s not an application platform. An application platform takes care of bundling, network transport, deployment, etc. Mantra uses Meteor as the application platform.</li><li>It&rsquo;s not a boilerplate, even though we have a directory structure.</li><li>It&rsquo;s not a code generator. We may have a code&#8208;generation tool, but that&rsquo;s not a core part of Mantra.</li></ul></section><section id="sec-What-is-Mantra-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-What-is-Mantra-">1.3</a></span>What is Mantra?</h3><ul><li>It&rsquo;s a set of standards for how to architect a Meteor app.</li><li>It also comes with a set of curated libraries that help you implement Mantra on top of Meteor.</li></ul></section><section id="sec-Why-a-Spec-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Why-a-Spec-">1.4</a></span>Why a Spec?</h3><p>Mantra is an application architecture. There will be a lot of stakeholders for Mantra, including app developers, tool builders, tutorial authors, and project managers, so it&rsquo;s very important to have a common standard everyone follows. That&rsquo;s what this specification does.</p></section><section id="sec-Before-You-Read"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Before-You-Read">1.5</a></span>Before You Read</h3><p>This specification is written in a simple language. However, you may feel more comfortable if you have a sound knowledge of the following areas.</p><ul><li>ES2015</li><li>React</li><li>React Containers</li><li>Meteor Basics (Pub/Sub, Tracker, ReactiveDict, etc.)</li></ul><p>Refer to <a href="#sec-Appendix-Prerequisite">Appendix A</a> to learn more about the above areas. </p></section></section><section id="sec-Core-Components"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Core-Components">2</a></span>Core Components</h2><p>Here are the core components of Mantra and how they are organized:</p><section id="sec-Client-Side-Focus"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Client-Side-Focus">2.1</a></span>Client-Side Focus</h3><p>Mantra gives special attention to the <strong>client side</strong> of your app. Mantra does not mix client and server code together; instead, it recommends code sharing. Here are the reasons why:</p><ul><li>Client side is where you put in a lot of effort. It&rsquo;s the biggest part of your codebase. Server&#8208;side codebase is relatively simpler to manage and organize.</li><li>In the future, client&#8208;side apps will interact with the server using a schema. Client&#8208;side apps will have no idea how the server was implemented.</li><li>Mantra <a href="https://voice.kadira.io/say-no-to-isomorphic-apps-b7b7c419c634#.hogcs5r24">does not believe in Universal Apps</a>. It encourages multiple apps for different platforms with code sharing. Then it&rsquo;s common to have a single server to interact with a few client apps.</li></ul><p>Based on the above factors, it&rsquo;s not a good idea to mix client and server code together.</p><p><strong>When we discuss Mantra further in this specification, it will be about the client side of your app.</strong></p><p>However, most of the apps will have server&#8208;side components. So, we have a directory layout for the server side as well. For that, refer to <a href="#sec-Appendix-Server-Side-Directory-Layout">Appendix B</a>.</p></section><section id="sec-ES2015-Syntax-and-ES2015-Modules"><h3><span class="spec-secid" title="link to this section"><a href="#sec-ES2015-Syntax-and-ES2015-Modules">2.2</a></span>ES2015 Syntax and ES2015 Modules</h3><p>We rely on different features of ES2015 and its module system. In order to use Mantra, you need to use <a href="https://forums.meteor.com/t/meteor-1-3-early-beta-now-available/14723">Meteor 1.3</a>, which comes with an implementation of the ES2015 module system.</p></section><section id="sec-React-as-the-UI"><h3><span class="spec-secid" title="link to this section"><a href="#sec-React-as-the-UI">2.3</a></span>React as the UI</h3><p>We use React as the UI (presentation) layer in Mantra.</p><p>When creating UI components you should pass all data and event handlers via props.</p><div class="spec-note">You could handle the React state inside a component, but that should not interact with the rest of your app. Therefore, Mantra highly recommends you avoid using states.</div><p>When writing your UI components, you can include any other React component. Here are some places you can import React components:</p><ul><li>Other UI components you define in your app.</li><li>UI components from NPM (like material&#8208;ui).</li><li>Any Containers in your app (we&rsquo;ll talk about this in a moment).</li></ul><p>You can also import any library function and use them in the UI components. You can import them directly from NPM modules, but not from any Meteor packages. These functions should be <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a>.</p><p>Here&rsquo;s a simple UI component:</p><pre><code>import React from 'react';

const PostList = ({posts}) =&gt; (
  <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">'postlist'</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
      {posts.map(post =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-title">li</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{post._id}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">a</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">{`</span>/<span class="hljs-attribute">post</span>/${<span class="hljs-attribute">post._id</span>}`}&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-title">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
);

export default PostList;
</code></pre></section><section id="sec-Actions"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Actions">2.4</a></span>Actions</h3><p>Actions are where you write the <strong>business logic</strong> in your app. This includes:</p><ul><li>Validations</li><li>State management</li><li>Interacting with remote data sources</li></ul><p>An action is a simple function that accepts the first argument as the whole <a href="#sec-Application-Context">Application Context</a> in your app. Other arguments usually come when invoking the action.</p><div class="spec-note">Inside an action, everything you do should be based on the Application Context and other arguments passed to the action. You should not import any ES2015 module except <a href="#sec-Libraries">libraries</a>. You should also avoid using Global variables inside actions.</div><p>Here are some actions:</p><pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  create({Meteor, LocalState, FlowRouter}, title, content) {
    <span class="hljs-keyword">if</span> (!title || !content) {
      <span class="hljs-keyword">return</span> LocalState.set(<span class="hljs-string">'SAVING_ERROR'</span>, <span class="hljs-string">'Title &amp; Content are required!'</span>);
    }

    LocalState.set(<span class="hljs-string">'SAVING_ERROR'</span>, <span class="hljs-literal">null</span>);

    <span class="hljs-keyword">const</span> id = Meteor.uuid();
    <span class="hljs-comment">// There is a method stub for this in the config/method_stubs</span>
    <span class="hljs-comment">// That's how we are doing latency compensation</span>
    Meteor.call(<span class="hljs-string">'posts.create'</span>, id, title, content, (err) =&gt; {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">return</span> LocalState.set(<span class="hljs-string">'SAVING_ERROR'</span>, err.message);
      }
    });
    FlowRouter.go(<span class="hljs-string">`/post/<span class="hljs-subst">${id}</span>`</span>);
  },

  clearErrors({LocalState}) {
    <span class="hljs-keyword">return</span> LocalState.set(<span class="hljs-string">'SAVING_ERROR'</span>, <span class="hljs-literal">null</span>);
  }
};
</code></pre></section><section id="sec-State-Management"><h3><span class="spec-secid" title="link to this section"><a href="#sec-State-Management">2.5</a></span>State Management</h3><p>In an app, we need to deal with different kinds of states. We can divide them into two different categories:</p><ol><li>Local State &ndash; State in the client&#8208;side app that will never be synced with a remote server (errors, validation messages, current page).</li><li>Remote State &ndash; This is the state usually fetched from a remote server and synced with it.</li></ol><p>We have different solutions for managing states in our app, including:</p><ul><li>Meteor/MiniMongo (Remote State)</li><li>Tracker/ReactiveDict (Local State)</li><li>FlowRouter (Local State)</li><li>Redux (Local State)</li><li>GraphQL (Remote State)</li><li>Falcor (Remote State)</li></ul><p>This is where a lot of innovation is happening in the JavaScript community. So, Mantra is flexible when it comes to state management. You can use anything you want.</p><p>For example, you can use the following for your app when starting:</p><ul><li>Meteor/MiniMongo (Remote State)</li><li>Tracker/ReactiveDict (Local State)</li><li>FlowRouter (Local State)</li></ul><p>Later on you can move on to different solutions.</p><div class="spec-note">However, Mantra enforces a few rules when managing your states.</div><ul><li>Any write operations to states should be done inside an action.</li><li>You can read states in both actions and containers.</li><li>You should not read or write into states directly inside UI components. UI components should know nothing about states in your app.</li></ul><p>See the following links for some sample usage of states:</p><ul><li><a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/newpost.js#L6">Reading from local state &ndash; inside a container</a></li><li><a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/actions/posts.js#L4">Writing into local state &ndash; inside an action</a></li><li><a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/postlist.js#L7">Reading from a remote state &ndash; inside a container</a></li></ul></section><section id="sec-Containers"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Containers">2.6</a></span>Containers</h3><p>Containers are the integration layer in Mantra. They perform these actions:</p><ul><li>Pass states into UI components.</li><li>Pass actions into UI components.</li><li>Pass items in Application Context into UI components.</li></ul><p>A container is a React component.</p><p>Containers are composed using <a href="https://github.com/kadirahq/react-komposer">react&#8208;komposer</a>. It supports different data sources, including Meteor/Tracker, Promises, Rx.js Observable, and nearly anything else.</p><p>Normally, inside a container you need to write the following functions:</p><ul><li>composer functions to get data from state managers.</li><li>mapper function to get data from dependency injection layer.</li></ul><p>We have some rules when creating a container:</p><ul><li>There should be only one container inside a single file and the container should be the default export.</li><li>composer functions and the mapper function should be exported from the container module.</li><li>Composer functions should only use variables coming via props.</li><li>The mapper function should be <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a>.</li></ul><div class="spec-note">If you need to pass the Application Context to a component, do it via props using a mapper.</div><p>Here&rsquo;s an example container:</p><pre><code><span class="hljs-keyword">import</span> PostList <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/postlist.jsx'</span>;
<span class="hljs-keyword">import</span> {useDeps, composeWithTracker, composeAll} <span class="hljs-keyword">from</span> <span class="hljs-string">'mantra-core'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> composer = ({context}, onData) =&gt; {
  <span class="hljs-keyword">const</span> {Meteor, Collections} = context();
  <span class="hljs-keyword">if</span> (Meteor.subscribe(<span class="hljs-string">'posts.list'</span>).ready()) {
    <span class="hljs-keyword">const</span> posts = Collections.Posts.find().fetch();
    onData(<span class="hljs-literal">null</span>, {posts});
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> composeAll(
  composeWithTracker(composer),
  useDeps()
)(PostList);
</code></pre></section><section id="sec-Application-Context"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Application-Context">2.7</a></span>Application Context</h3><p>Application Context is available to all actions and containers, so this is the place for shared variables in your app. These include:</p><ul><li>Meteor namespace</li><li>Meteor Collections</li><li>LocalState</li><li>FlowRouter</li><li>Any other Meteor package</li><li>Redux Stores</li><li>Rest Clients</li><li>DDP Clients</li></ul><p>Here&rsquo;s a simple Application Context:</p><pre><code><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> Collections <span class="hljs-keyword">from</span> <span class="hljs-string">'/lib/collections'</span>;
<span class="hljs-keyword">import</span> {Meteor} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/meteor'</span>;
<span class="hljs-keyword">import</span> {FlowRouter} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/kadira:flow-router'</span>;
<span class="hljs-keyword">import</span> {ReactiveDict} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/reactive-dict'</span>;
<span class="hljs-keyword">import</span> {Tracker} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/tracker'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    Meteor,
    FlowRouter,
    Collections,
    LocalState: <span class="hljs-keyword">new</span> ReactiveDict(),
    Tracker
  };
}
</code></pre></section><section id="sec-Dependency-Injection"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Dependency-Injection">2.8</a></span>Dependency Injection</h3><p>Mantra uses dependency injection to isolate different parts of your app including UI components and actions.</p><p>We use a project called <a href="https://github.com/kadirahq/react-simple-di"><code>react-simple-di</code></a> that uses React Context behind the scenes. It accepts both <a href="#sec-Application-Context">Application Context</a> and <a href="#sec-Actions">Actions</a> as dependencies.</p><p>Once configured, Application Context will be injected into each action. That&rsquo;s the first argument of an action. So, you don&rsquo;t need to pass the application context manually.</p><p>Application Context can be accessed within <a href="#sec-Containers">Containers</a> as well.</p><section id="sec-Configuring-Dependency-Injections"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Configuring-Dependency-Injections">2.8.1</a></span>Configuring Dependency Injections</h4><p>Dependencies will be injected into the top&#8208;level components in your app. Usually, it&rsquo;ll be a Layout Component. You can do the injection inside your routes. See:</p><pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">injectDeps</span>) </span>{
  <span class="hljs-comment">// See: Injecting Deps</span>
  <span class="hljs-keyword">const</span> MainLayoutCtx = injectDeps(MainLayout);

  <span class="hljs-comment">// Routes related code</span>
}
</code></pre></section></section><section id="sec-Routing-Component-Mounting"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Routing-Component-Mounting">2.9</a></span>Routing &amp; Component Mounting</h3><div class="spec-note">When we refer to components, we consider both containers and UI components.</div><p>We normally use a Router to mount components to the UI. There could be multiple solutions (for example, <a href="https://github.com/kadirahq/flow-router/">Flow Router</a> and <a href="https://github.com/rackt/react-router">React Router</a>).</p><p>The Router&rsquo;s only functionality in Mantra is to mount components to the UI. It&rsquo;s just a tool.</p><p>See how to use FlowRouter as the router:</p><pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {FlowRouter} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/kadira:flow-router'</span>;
<span class="hljs-keyword">import</span> {mount} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mounter'</span>;

<span class="hljs-keyword">import</span> MainLayout <span class="hljs-keyword">from</span> <span class="hljs-string">'/client/modules/core/components/layout.main.jsx'</span>;
<span class="hljs-keyword">import</span> PostList <span class="hljs-keyword">from</span> <span class="hljs-string">'/client/modules/core/containers/postlist'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">injectDeps</span>) </span>{
  <span class="hljs-keyword">const</span> MainLayoutCtx = injectDeps(MainLayout);

  FlowRouter.route(<span class="hljs-string">'/'</span>, {
    name: <span class="hljs-string">'posts.list'</span>,
    action() {
      mount(MainLayoutCtx, {
        content: () =&gt; (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PostList</span> /&gt;</span>)</span>
      });
    }
  });
}
</code></pre><div class="spec-note">If you need to redirect upon some condition (for example user is not authorized) use an action instead of route options like FlowRouter&rsquo;s triggersEnter. Call the action from component or container&rsquo;s composer function.</div></section><section id="sec-Libraries"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Libraries">2.10</a></span>Libraries</h3><p>Every app has some utility functions to do different tasks. You can also get them via NPM. These libraries will export functions. So, you can import them anywhere in your app including inside actions, components, and containers. But they must be <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a>.</p></section><section id="sec-Testing"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Testing">2.11</a></span>Testing</h3><p>Testing is a core part of Mantra. Mantra helps you test every part of your application. Rules we&rsquo;ve enforced will help you write those tests. You can use familiar tools such as <a href="https://mochajs.org/">Mocha</a>, <a href="http://chaijs.com/">Chai</a>, and <a href="http://sinonjs.org/">Sinon</a> to perform testing.</p><p>With Mantra, you can unit test three core parts in your app. See:</p><ul><li>UI components - <a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js">Example</a></li><li>Actions - <a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/actions/tests/posts.js">Example</a></li><li>Container composers and deps mappers - <a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/containers/tests/post.js">Example</a></li></ul><section id="sec-UI-Testing"><h4><span class="spec-secid" title="link to this section"><a href="#sec-UI-Testing">2.11.1</a></span>UI Testing</h4><p>For the UI testing we use <a href="https://github.com/airbnb/enzyme">enzyme</a>. Click <a href="https://github.com/mantrajs/mantra-sample-blog-app/blob/master/client/modules/core/components/tests/post.js">here</a> to see some sample test cases.</p></section></section><section id="sec-Mantra-Modules"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Mantra-Modules">2.12</a></span>Mantra Modules</h3><p>Mantra follows a modular architecture. All the components of Mantra except <a href="#sec-Application-Context">&ldquo;Application Context&rdquo;</a> should reside inside a module.</p><p>You can create as many as modules you like and communicate between them via imports.</p><section id="sec-Application-Context-Modules"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Application-Context-Modules">2.12.1</a></span>Application Context &amp; Modules</h4><p><a href="#sec-Application-Context">Application Context</a> is the core of the application. It needs to be defined in a place which does not belong to any module. All the modules can access Application Context as a dependency and modules should not update the Application Context.</p></section><section id="sec-Module-Definition"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Module-Definition">2.12.2</a></span>Module Definition</h4><p>A Mantra module may contain a definition file. It exposes actions, routes, and a function accepting the context. It is the <code>index.js</code> file of a module.</p><p>A simple module definition looks like this:</p><pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-comment">// optional</span>
  load(context, actions) {
    <span class="hljs-comment">// do any module initialization</span>
  },
  <span class="hljs-comment">// optional</span>
  actions: {
    myNamespace: {
      doSomething: (context, arg1) =&gt; {}
    }
  },
  <span class="hljs-comment">// optional</span>
  routes(injectDeps) {
    <span class="hljs-keyword">const</span> InjectedComp = injectDeps(MyComp);
    <span class="hljs-comment">// load routes and put `InjectedComp` to the screen.</span>
  }
};
</code></pre></section><section id="sec-Implicit-Modules"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Implicit-Modules">2.12.3</a></span>Implicit Modules</h4><p>If the module has no actions or routes, or no need to do any initialization, then it&rsquo;s okay to avoid using a definition file. These implicit modules may contain the following:</p><ul><li>UI components</li><li>Containers</li><li>Libraries</li></ul></section><section id="sec-Module-Containers-UI-Components"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Module-Containers-UI-Components">2.12.4</a></span>Module Containers &amp; UI Components</h4><p>Module containers and UI components should be able to be imported via ES2015 modules.</p></section><section id="sec-Module-Actions"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Module-Actions">2.12.5</a></span>Module Actions</h4><p>A module can expose actions via namespaces. These namespaces are global to the app and the module should take responsibility for making them unique. A module can expose multiple namespaces.</p><p>Finally, all these namespaces from each module are merged and can be accessible inside actions and containers.</p></section><section id="sec-Routes"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Routes">2.12.6</a></span>Routes</h4><p>For routing, you can use any routing library. It&rsquo;s okay to have route definitions inside multiple modules if needed.</p></section><section id="sec-Core-Module"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Core-Module">2.12.7</a></span>Core Module</h4><p>Mantra is 100% modular and there should be at least one in an app. We call this the core module. It&rsquo;s just a simple module, but you load it before any other module. This module is the best place to put:</p><ul><li>core routes,</li><li>application configurations,</li><li>common libraries,</li><li>common actions</li></ul><p>and other application&#8208;specific code.</p><p>There are multiple ways to organize modules depending on the app. Refer to <a href="#sec-Appendix-Organizing-Modules">Appendix C</a> for some of those methods.</p></section><section id="sec-Sub-Modules"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Sub-Modules">2.12.8</a></span>Sub Modules</h4><p>Inside a module, you <strong>cannot</strong> have sub modules. This is a decision made to prevent unnecessary complexity. Otherwise, it&rsquo;s possible to write multiple layers of nested modules, and that&rsquo;s very hard to manage.</p></section></section><section id="sec-Single-Entry-Point"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Single-Entry-Point">2.13</a></span>Single Entry Point</h3><p>With Mantra, we want our app to be predictable. Therefore, there is a single entry point in your app. That&rsquo;s the <code>client/main.js</code>.</p><p>It&rsquo;ll initialize the Application Context and load all the modules in your app. Here&rsquo;s an example <code>client/main.js</code> file:</p><pre><code><span class="hljs-keyword">import</span> {createApp} <span class="hljs-keyword">from</span> <span class="hljs-string">'mantra-core'</span>;
<span class="hljs-keyword">import</span> {initContext} <span class="hljs-keyword">from</span> <span class="hljs-string">'./configs/context'</span>;

<span class="hljs-comment">// modules</span>
<span class="hljs-keyword">import</span> coreModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/core'</span>;
<span class="hljs-keyword">import</span> commentsModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/comments'</span>;

<span class="hljs-comment">// init context</span>
<span class="hljs-keyword">const</span> context = initContext();

<span class="hljs-comment">// create app</span>
<span class="hljs-keyword">const</span> app = createApp(context);
app.loadModule(coreModule);
app.loadModule(commentsModule);
app.init();
</code></pre></section></section><section id="sec-Directory-Layout"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Directory-Layout">3</a></span>Directory Layout</h2><p>In Mantra, we enforce a common directory structure. That&rsquo;s the core part of the maintainability of any app.</p><div class="spec-note">In this section, we only discuss the client&#8208;side directory layout. To learn about how to organize the server&#8208;side directory layout, refer to <a href="#sec-Appendix-Server-Side-Directory-Layout">Appendix B</a>.</div><section id="sec-Top-Level-Directory-Structure"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Top-Level-Directory-Structure">3.1</a></span>Top-Level Directory Structure</h3><p>All the Mantra&#8208;related code stays inside the <code>client</code> directory of the app. Inside that, there are usually two directories and one JavaScript file. They are:</p><pre><code>* configs
* modules
* main.js
</code></pre><p>Let&rsquo;s have a look at each of these in detail.</p><section id="sec-Top-Level-Directory-Structure.configs"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Top-Level-Directory-Structure.configs">3.1.1</a></span>configs</h4><p>This directory contains root&#8208;level configurations in your app. Usually, this is a place to put app&#8208;wide configurations which are common to all modules.</p><p>All JavaScript files in this directory should have a default export function which initiates some tasks and returns something if needed.</p><div class="spec-note">This is where we usually place <a href="#sec-Application-Context">Application Context</a> as <code>context.js</code>.</div></section><section id="sec-modules"><h4><span class="spec-secid" title="link to this section"><a href="#sec-modules">3.1.2</a></span>modules</h4><p>This directory contains one or more modules (in their own directories) in your app. There should be at least a single module, and it&rsquo;s usually named <code>core</code>.</p><p>This is what is usually inside a module directory:</p><pre><code>* actions
* components
* configs
* containers
* libs
* routes.jsx
* index.js
</code></pre><p>Let&rsquo;s learn more about these directories and files.</p><section id="sec-actions"><h5><span class="spec-secid" title="link to this section"><a href="#sec-actions">3.1.2.1</a></span>actions</h5><p>This directory contains all <a href="#sec-Actions">actions</a> in the module. Here&rsquo;s a sample directory layout inside it:</p><pre><code>* posts.js
* index.js
* tests
    - posts.js
</code></pre><p><code>posts.js</code> is an ES2015 module that exports a JavaScript object with actions. For example, here&rsquo;s a simple action module:</p><pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  create({Meteor, LocalState, FlowRouter}, title, content) {
    <span class="hljs-comment">//...</span>
  },

  clearErrors({LocalState}) {
    <span class="hljs-comment">//...</span>
  }
};
</code></pre><p>Then, in the <code>index.js</code>, we import all the action modules and aggregate all actions. We give a namespace for each module.</p><pre><code><span class="hljs-keyword">import</span> posts <span class="hljs-keyword">from</span> <span class="hljs-string">'./posts'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  posts
};
</code></pre><p>In the above example, we&rsquo;ve given <code>posts</code> as the namespace for the <code>posts.js</code> action module.</p><div class="spec-note">These namespaces should be unique across the app. That&rsquo;s a responsibility of the module.</div><p>In the tests directory, we write tests for each action module with its name. Refer to <a href="#sec-Appendix-File-Naming-Conventions">Appendix D</a> to learn more about test file naming conventions.</p><p><a href="https://github.com/mantrajs/mantra-sample-blog-app/tree/master/client/modules/core/actions">Click here to see the directory layout for actions</a></p></section><section id="sec-components"><h5><span class="spec-secid" title="link to this section"><a href="#sec-components">3.1.2.2</a></span>components</h5><p>Components contain <a href="#sec-React-as-the-UI">UI components</a> of the module. It has a directory layout like this:</p><pre><code>* layouts.main.jsx
* post.jsx
* style.css
* tests
  - layouts.main.js
  - post.js
</code></pre><ul><li>All the <code>.jsx</code> files in this directory should have a default export. It should be a React class.</li><li>You can have CSS files related to these React components and Meteor will bundle them for you.</li></ul><p>Just like in actions, we have a tests directory that contains tests. Refer to <a href="#sec-Appendix-File-Naming-Conventionssec-Appendix-File-Naming-Conventions">Appendix D</a> for test file naming conventions.</p><p><a href="https://github.com/mantrajs/mantra-sample-blog-app/tree/master/client/modules/core/components">Click here to see the directory layout for components.</a></p></section><section id="sec-containers"><h5><span class="spec-secid" title="link to this section"><a href="#sec-containers">3.1.2.3</a></span>containers</h5><p>This directory contains a set of <code>.js</code> files, with each of them representing a single container. Each file should have its default export as a React Container class.</p><p>Here&rsquo;s a common directory layout:</p><pre><code>* post.js
* postlist.js
* tests
    - post.js
    - postlist.js
</code></pre><p>This directory also has a <code>tests</code> directory which contain tests. Refer to <a href="#sec-Appendix-File-Naming-Conventions">Appendix D</a> for test file naming conventions.</p><p><a href="https://github.com/mantrajs/mantra-sample-blog-app/tree/master/client/modules/core/containers">Click here to see the directory layout for containers.</a></p></section><section id="sec-modules.configs"><h5><span class="spec-secid" title="link to this section"><a href="#sec-modules.configs">3.1.2.4</a></span>configs</h5><p>This directory contains the module&#8208;level configurations in your app.</p><p>All the JavaScript files in this directory must export a default function which initiates any task and returns something if needed. That function may accept <a href="#sec-Application-Context">&ldquo;Application Context&rdquo;</a> as the first argument.</p><p>Here&rsquo;s a simple config file:</p><pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>{
  <span class="hljs-comment">// do something</span>
}
</code></pre><p>These configurations can be imported and called when loading the module.</p><div class="spec-note">Usually, this is where we keep Meteor method stubs which are used for optimistic updates.</div><p><a href="https://github.com/mantrajs/mantra-sample-blog-app/tree/master/client/modules/core/configs">Click here to see the directory layout for configs.</a></p></section><section id="sec-modules.libs"><h5><span class="spec-secid" title="link to this section"><a href="#sec-modules.libs">3.1.2.5</a></span>libs</h5><p>This directory contains a set of JavaScript files (<code>.js</code> or <code>.jsx</code>) which exports a set of utility (pure) functions. This is also known as <a href="#sec-Libraries">libraries</a>. You may write tests for libraries inside a subdirectory called <code>tests</code>.</p></section><section id="sec-routes-jsx"><h5><span class="spec-secid" title="link to this section"><a href="#sec-routes-jsx">3.1.2.6</a></span>routes.jsx</h5><p>This is the file containing route definitions of the module. It has a default export which is a function. This is a typical routes definition:</p><pre><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {FlowRouter} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/kadira:flow-router'</span>;
<span class="hljs-keyword">import</span> {mount} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-mounter'</span>;

<span class="hljs-keyword">import</span> MainLayout <span class="hljs-keyword">from</span> <span class="hljs-string">'/client/modules/core/components/layout.main.jsx'</span>;
<span class="hljs-keyword">import</span> PostList <span class="hljs-keyword">from</span> <span class="hljs-string">'/client/modules/core/containers/postlist'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">injectDeps</span>) </span>{
  <span class="hljs-keyword">const</span> MainLayoutCtx = injectDeps(MainLayout);

  FlowRouter.route(<span class="hljs-string">'/'</span>, {
    name: <span class="hljs-string">'posts.list'</span>,
    action() {
      mount(MainLayoutCtx, {
        content: () =&gt; (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">PostList</span> /&gt;</span>)</span>
      });
    }
  });
}
</code></pre><p>This default export is called with a function called <code>injectDeps</code> while loading the module. The <code>injectDeps</code> function can be used to inject dependencies into a React component (or a container) as shown above.</p></section><section id="sec-index-js"><h5><span class="spec-secid" title="link to this section"><a href="#sec-index-js">3.1.2.7</a></span>index.js</h5><p>This is the module <a href="#sec-Module-Definition">definition file</a> of the module. There is no need for this module definition file if there is no need to do any of the following tasks:</p><ul><li>To load routes.</li><li>To define actions.</li><li>To run configurations while loading the module.</li></ul><p>Here&rsquo;s a typical module definition:</p><pre><code><span class="hljs-keyword">import</span> methodStubs <span class="hljs-keyword">from</span> <span class="hljs-string">'./configs/method_stubs'</span>;
<span class="hljs-keyword">import</span> actions <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>;
<span class="hljs-keyword">import</span> routes <span class="hljs-keyword">from</span> <span class="hljs-string">'./configs/routes.jsx'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  routes,
  actions,
  load(context) {
    methodStubs(context);
  }
};
</code></pre><p>In the module definition, <code>.load()</code> method gets called when the module is loading. So, it&rsquo;s the place to invoke configurations.</p></section></section><section id="sec-Top-Level-Directory-Structure.main-js"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Top-Level-Directory-Structure.main-js">3.1.3</a></span>main.js</h4><p>This is the entry point of a Mantra app. It initializes the application context and loads modules. For that, it uses a utility library called <a href="https://github.com/mantrajs/mantra-core"><code>mantra-core</code></a>.</p><p>Here&rsquo;s a sample <code>main.js</code> file:</p><pre><code><span class="hljs-keyword">import</span> {createApp} <span class="hljs-keyword">from</span> <span class="hljs-string">'mantra-core'</span>;
<span class="hljs-keyword">import</span> initContext <span class="hljs-keyword">from</span> <span class="hljs-string">'./configs/context'</span>;

<span class="hljs-comment">// modules</span>
<span class="hljs-keyword">import</span> coreModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/core'</span>;
<span class="hljs-keyword">import</span> commentsModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/comments'</span>;

<span class="hljs-comment">// init context</span>
<span class="hljs-keyword">const</span> context = initContext();

<span class="hljs-comment">// create app</span>
<span class="hljs-keyword">const</span> app = createApp(context);
app.loadModule(coreModule);
app.loadModule(commentsModule);
app.init();
</code></pre></section></section></section><section id="sec-Future-Work"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Future-Work">4</a></span>Future Work</h2><p>Mantra is a draft and there will be missing pieces and improvements we can make. We&rsquo;ve identified the following features as important to Mantra and they will be available in the near future.</p><section id="sec-Server-Side-Rendering-SSR-"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Server-Side-Rendering-SSR-">4.1</a></span>Server-Side Rendering (SSR)</h3><p>It&rsquo;s extremely possible to do SSR with Mantra. We are trying to do this in a tool&#8208;agnostic manner, but the reference implementation will be based on <a href="https://github.com/kadirahq/flow-router/tree/ssr">FlowRouter SSR</a>.</p></section><section id="sec-Distributing-Mantra-Modules-via-NPM"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Distributing-Mantra-Modules-via-NPM">4.2</a></span>Distributing Mantra Modules via NPM</h3><p>We could distribute Mantra modules via NPM. Once we do that, we could do reuse a lot of code between apps and organizations.</p></section><section id="sec-Standard-for-Styling"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Standard-for-Styling">4.3</a></span>Standard for Styling</h3><p>It&rsquo;s better to have a standard for styling UI components.</p></section><section id="sec-Standard-for-Tests"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Standard-for-Tests">4.4</a></span>Standard for Tests</h3><p>It&rsquo;s better to have a standard for writing test cases.</p></section><section id="sec-Reusing-Composers"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Reusing-Composers">4.5</a></span>Reusing Composers</h3><p>Sometimes, we can use reuse composers for the same function in many places. We need to find a pattern for doing that. </p></section></section><section id="sec-Contributing-to-Mantra"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Contributing-to-Mantra">5</a></span>Contributing to Mantra</h2><p>This is a draft specification of Mantra.</p><p>To get started with Mantra, try following our sample app. It uses most of the features in Mantra.</p><ul><li><a href="http://mantra-sample-blog.meteor.com/">Access It Online</a></li><li><a href="https://github.com/mantrajs/mantra-sample-blog-app">Clone It</a></li></ul><p>We need your input for improving Mantra, so try using Mantra and let&rsquo;s <a href="https://github.com/kadirahq/mantra/issues">discuss</a> how we can improve it.</p><ul><li><a href="https://github.com/kadirahq/mantra">GitHub Repo</a> </li></ul></section><section id="sec-Appendix-Prerequisite"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Prerequisite">A</a></span>Appendix: Prerequisite</h2><p>These resources will help you understand Mantra very clearly.</p><section id="sec-ES2015"><h3><span class="spec-secid" title="link to this section"><a href="#sec-ES2015">A.1</a></span>ES2015</h3><p>ES2015 is the standard version of JavaScript for 2015. It&rsquo;s not fully implemented by all browsers or server&#8208;side environments. But, using transpilers like <a href="https://babeljs.io/">babel</a>, we can use E2015 today.</p><div class="spec-note">Meteor has built&#8208;in support for ES2015</div><p>ES2015 is the best thing happen to JavaScript. It introduces a lot of features and fixes a lot of common issues.</p><ul><li><a href="https://tutor.mantrajs.com/say-hello-to-ES2015/introduction">Learn ES2015: Say Hello to ES2015</a></li></ul></section><section id="sec-React"><h3><span class="spec-secid" title="link to this section"><a href="#sec-React">A.2</a></span>React</h3><p>React is a UI framework based on JavaScript. Basically, you create the UI inside JavaScript. At first, <strong>it feels weird</strong>. But you&rsquo;ll find it very interesting once you learn the basics.</p><p>Just forget about what you already know about HTML for a moment, and learn React. Then rethink. Here are some resources:</p><ul><li><a href="https://facebook.github.io/react/docs/tutorial.html">Official Tutorial</a></li><li><a href="https://scotch.io/tutorials/learning-react-getting-started-and-concepts">Getting Started Tutorial at Scotch.io</a></li><li><a href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca">React Components, Elements, and Instances</a></li></ul></section><section id="sec-React-Containers"><h3><span class="spec-secid" title="link to this section"><a href="#sec-React-Containers">A.3</a></span>React Containers</h3><p>Now, we rarely use states in React components. Instead, we accept data via props. React&rsquo;s <a href="https://medium.com/@joshblack/stateless-components-in-react-0-14-f9798f8b992d">stateless components</a> make it very easy.</p><p>Then, we compose React containers to fetch data from different sources and load them into UI components. Projects like <a href="https://github.com/kadirahq/react-komposer">react&#8208;komposer</a> make it simple. Check out the following article for more information:</p><ul><li><a href="https://voice.kadira.io/let-s-compose-some-react-containers-3b91b6d9b7c8#.my9ynz9e2">Let&rsquo;s Compose Some React Containers</a></li></ul></section><section id="sec-Meteor-Basics"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Meteor-Basics">A.4</a></span>Meteor Basics</h3><p>You need to have a better understanding of Meteor. For that, follow Meteor&rsquo;s <a href="https://www.meteor.com/tutorials/react/creating-an-app">official tutorial</a>.</p><div class="spec-note">Mantra uses some of the above technologies a bit differently. For an example, Meteor&rsquo;s React tutorial suggests using a mixin to access Mongo collection data. But Mantra uses a container, which is the modern way to use React. </div></section></section><section id="sec-Appendix-Server-Side-Directory-Layout"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Server-Side-Directory-Layout">B</a></span>Appendix: Server-Side Directory Layout</h2><p>This is a directory layout for the server side part of your app. This is <strong>not</strong> a core part of Mantra, but it follows the directory layout we used for the client side of our app.</p><p>On the server side, we have four main directories and a JavaScript file called <code>main.js</code>.</p><pre><code>* methods
* publications
* libs
* configs
* main.js
</code></pre><p>Let&rsquo;s see what each of these directories and files does.</p><section id="sec-methods"><h3><span class="spec-secid" title="link to this section"><a href="#sec-methods">B.1</a></span>methods</h3><p>This is the directory where we can put methods in your app. This is how the files in this directory look like:</p><pre><code>* posts.js
* index.js
* tests
  - posts.js
</code></pre><p>Here we have a file called <code>posts.js</code> which has methods for the feature <code>posts</code> in our app. Depending your app, we can have different files.</p><p>Inside this JavaScript file, we have a default export which is a function. Meteor methods are defined inside that function.</p><p>When naming methods inside the <code>posts.js</code>, always prefix the method name. That prefix is the name of the file with a dot (.).</p><p>In our case, the prefix is <code>posts.</code></p><p>For an example, here are some methods inside <code>posts.js</code>:</p><pre><code><span class="hljs-keyword">import</span> {Posts, Comments} <span class="hljs-keyword">from</span> <span class="hljs-string">'/lib/collections'</span>;
<span class="hljs-keyword">import</span> {Meteor} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/meteor'</span>;
<span class="hljs-keyword">import</span> {check} <span class="hljs-keyword">from</span> <span class="hljs-string">'meteor/check'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  Meteor.methods({
    <span class="hljs-string">'posts.create'</span>(_id, title, content) {
      <span class="hljs-comment">//  method body</span>
    }
  });

  Meteor.methods({
    <span class="hljs-string">'posts.createComment'</span>(_id, postId, text) {
      <span class="hljs-comment">//  method body</span>
    }
  });
}
</code></pre><p>Finally, there is a file called <code>index.js</code> which imports all other modules in this directory and invokes them in a default export. So, when importing methods, we can do it with a single import.</p><p>Here&rsquo;s a sample <code>index.js</code> file:</p><pre><code><span class="hljs-keyword">import</span> posts <span class="hljs-keyword">from</span> <span class="hljs-string">'./posts'</span>;
<span class="hljs-keyword">import</span> admin <span class="hljs-keyword">from</span> <span class="hljs-string">'./admin'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  posts();
  admin();
}
</code></pre><section id="sec-Tests"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Tests">B.1.1</a></span>Tests</h4><p>We can write tests for methods inside the tests directory. For that, it&rsquo;s a better to do integration testing rather doing unit tests.</p><p>For that, you can use <a href="https://github.com/anticoders/gagarin">Gagarin</a>.</p></section></section><section id="sec-publications"><h3><span class="spec-secid" title="link to this section"><a href="#sec-publications">B.2</a></span>publications</h3><p>This directory is identical to the <code>methods</code> directory, but we write publications instead of methods.</p></section><section id="sec-Appendix-Server-Side-Directory-Layout.libs"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Server-Side-Directory-Layout.libs">B.3</a></span>libs</h3><p>This directory contains utility functions which we can use inside the server.</p></section><section id="sec-Appendix-Server-Side-Directory-Layout.configs"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Server-Side-Directory-Layout.configs">B.4</a></span>configs</h3><p>This is the place where we can write configurations in our app. These configuration files should have a default export function which can be imported and invoked. Configuration code should stay inside that function.</p><p>Here&rsquo;s an example configuration:</p><pre><code><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">//  invoke the configuration here</span>
}
</code></pre></section><section id="sec-Appendix-Server-Side-Directory-Layout.main-js"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Server-Side-Directory-Layout.main-js">B.5</a></span>main.js</h3><p>This is the place where we can start as the entry point for our app. We&rsquo;ll import methods, publications and configuration inside this file and invoke.</p><p>Here&rsquo;s an example <code>main.js</code> file:</p><pre><code><span class="hljs-keyword">import</span> publications <span class="hljs-keyword">from</span> <span class="hljs-string">'./publications'</span>;
<span class="hljs-keyword">import</span> methods <span class="hljs-keyword">from</span> <span class="hljs-string">'./methods'</span>;
<span class="hljs-keyword">import</span> addInitialData <span class="hljs-keyword">from</span> <span class="hljs-string">'./configs/initial_adds.js'</span>;

publications();
methods();
addInitialData();
</code></pre><div class="spec-note">Have a look at this <a href="https://github.com/mantrajs/mantra-sample-blog-app/tree/master/server">sample app</a> to see how it has implemented these guidelines. </div></section></section><section id="sec-Appendix-Organizing-Modules"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-Organizing-Modules">C</a></span>Appendix: Organizing Modules</h2><p>Mantra has a 100% <a href="#sec-Mantra-Modules">module&#8208;based</a> app architecture. There should be at least a single module.</p><p>We&rsquo;ve discussed how to organize files inside a module and how to use them. But, we didn&rsquo;t discuss how to organize modules.</p><p>That&rsquo;s because it&rsquo;s different from app to app.</p><p>However, we are suggesting some potential patterns that can be used to organize modules.</p><section id="sec-Single-Core-Module"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Single-Core-Module">C.1</a></span>Single Core Module</h3><p>For a simple app, we can put all the code inside a single module and name it as <code>core</code>. This would work for a simple app where there is a smaller client&#8208;side codebase.</p></section><section id="sec-Core-Module-Multiple-Feature-Modules"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Core-Module-Multiple-Feature-Modules">C.2</a></span>Core Module &amp; Multiple Feature Modules</h3><p>This is an extended version of the above &ldquo;Single Module App&rdquo; pattern. Here it is:</p><ul><li>We have a core module containing all the core client&#8208;side code, including all the routes in the app.</li><li>Then we have different modules for major features in our app. These modules do not contain routes.</li></ul></section><section id="sec-Multi-Modules"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Multi-Modules">C.3</a></span>Multi Modules</h3><p>This the multi&#8208;module approach where there is no single core module.</p><ul><li>There are multiple modules for each main feature in the app.</li><li>Each of them has its own route.</li></ul></section><section id="sec-Pages-Module"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Pages-Module">C.4</a></span>Pages Module</h3><div class="spec-note">This can be used with any other pattern mentioned above.</div><p>Sometimes, we need to show some UI pages. They don&rsquo;t have their own actions, routes, or configurations. They only contain some UI code. These can be either UI components or some containers.</p><p>For this purpose, we can use an <a href="#sec-Implicit-Modules">implicit module</a>. </p></section></section><section id="sec-Appendix-File-Naming-Conventions"><h2><span class="spec-secid" title="link to this section"><a href="#sec-Appendix-File-Naming-Conventions">D</a></span>Appendix: File Naming Conventions</h2><p>In <a href="#sec-Directory-Layout">Directory Layout</a>, we discussed ways we can organize files for different components.</p><p>Here we discuss ways to name files.</p><section id="sec-Source-File-Names"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Source-File-Names">D.1</a></span>Source File Names</h3><p>When we remove the extension from the filename it should satisfy following conditions:</p><ul><li>All letters should be lower case.</li><li>Filename should be <a href="https://en.wikipedia.org/wiki/Alphanumeric">alphanumeric</a> and can have the <code>_</code> symbol.</li><li>Filename should start with a letter.</li></ul><p>Here&rsquo;s the regular expression for the above rules:</p><pre><code>/^[a-z]+[a-z0-<span class="hljs-number">9</span>_]+$/
</code></pre></section><section id="sec-Test-File-Names"><h3><span class="spec-secid" title="link to this section"><a href="#sec-Test-File-Names">D.2</a></span>Test File Names</h3><p>This is how we name files inside the <code>tests</code> directory. Here are the rules:</p><ul><li>There should be an identical filename in the source directory.</li><li>If not, when removing the postfix, there should be an identical filename in the source directory.</li></ul><section id="sec-Postfix"><h4><span class="spec-secid" title="link to this section"><a href="#sec-Postfix">D.2.1</a></span>Postfix</h4><p>Most of the time, we can have a test file for each source file. Sometimes, we need to create multiple test files for a single source file. That&rsquo;s where we&rsquo;ll use a postfix.</p><p>If that source filename is <code>posts.js</code>, then with the postfix it&rsquo;ll look like this:</p><pre><code>posts-part1.js
posts-part2.js
</code></pre><p>This is the regular expression for the above rules:</p><pre><code>/^([a-z]+[a-z0-<span class="hljs-number">9</span>_]+)(\-[a-z]+[a-z0-<span class="hljs-number">9</span>_]+)*$/
</code></pre></section></section></section><footer>Written in <a href="http://leebyron.com/spec-md/" target="_blank">Spec Markdown</a>.</footer></body></html>